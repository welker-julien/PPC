import threading
import multiprocessing

houses (nb)
	for i in range (0,nb)
		h = Process(target=Home, args=(i,))
		h.start()
 		h.join()
		
Home(i)
	#calcul conso avec température en kelvin
	C=temp x A
	#calcul production avec température en kelvin
	P= temp x b + temps x c
	if P> C
	# on vend
		mutex.acquire
		etat[i]=surprod
		mutex.release
		#attente de client
		delay(100)
		if message_queue != 0
			if type_message=demande
				if volume_demande<(P-C)
					accept demande
					
		
	elif P<C
	#on achète
		
		for j in range (0, len(etat[])
				messagequeue. (type=demande)
				break #pour ne pas aller demander à un autre 
				#de l'energie alors qu'on en a trouvé
				print(qqt energie,  num process vendeur,num process acheteur)
	else
	#inexistant car on ne fait rien dans ce cas là
		


External()
	coef=1
	While True
		i=random(0,100)
		if i==1
			send signal to market
		wait(i)

Market()
	qtt_energie=0
	prix=0.14
	ext = Process(target=External)
	ext.start()
 	ext.join()
	Price()
	def Price()
		chercher infos(température)
		prix=voir formule
		
		
	for element in queue :
		if semaphore=!0
			semaphore.acquire 
			trans = Thread(target=transaction, args(volume energie, n° home, type)
			trans.start()
 			trans.join()
			if type== vente
				qtt_energie=qtt_energie+qttachete
				Price()
			if type == achat
				qtt_energie=qtt_energie-qttvendue
				Price()
			semaphore.release
	
	transaction(volume, home,type)
		if type== vente
			inform home acceptation via la message queue
			print( qttachete, prix, num process home)
		if type == achat
			inform home acceptation via la message queue
			print( qttvendue, prix, num process home)

Weather()
	#temp est une variable dans la mémoire partagé
	while true
		temp=293 #-20°C
		for i allant de 0 à 60  
			temp=temp+1
		for j allant de 0 à 60
			temp=temp-1
